---
title: 101. Symmetric Tree
difficulty: easy
tags: [binary-tree, dfs, bfs]
---

import Code from '@/components/Code';

## Problem Statement

Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).

[View on LeetCode â†’](https://leetcode.com/problems/symmetric-tree/)

---

## Examples

### Example 1

```
Input: root = [1, 2, 2, 3, 4, 4, 3]
Output: true
```

### Example 2

```
Input: root = [1, 2, 2, null, 3, null, 3]
Output: false
```

---

## Approach

Two approaches work:

1. **DFS (Depth-First Search):** Recursively compare the left subtree (traversing left-then-right) against the right subtree (traversing right-then-left). At each step, both nodes must have equal values and mirror-symmetric children.

2. **BFS (Breadth-First Search):** Process nodes level by level, enqueueing mirror pairs `(left.left, right.right)` and `(left.right, right.left)`. Verify equality at each dequeue step.

The DFS approach is typically simpler to implement: `isMirror(left, right)` checks `left.val == right.val` and recurses on `(left.left, right.right)` and `(left.right, right.left)`.

---

## Complexity Analysis

**Time Complexity:** O(n), where n is the number of nodes. Every node is visited once.

**Space Complexity:** O(h) for DFS (recursion stack) or O(w) for BFS (queue), where h is the height and w is the maximum width.

---

## Solutions

### Go

<Code problemNumber={101} difficulty="easy" lang="go" />

---

## Key Insights

- Symmetry is checked by comparing mirror-image positions, not siblings.
- Base cases: two `null` nodes are symmetric; one `null` and one non-null are not.
- The key recursive call pairs `(node.left.left, node.right.right)` and `(node.left.right, node.right.left)`.
