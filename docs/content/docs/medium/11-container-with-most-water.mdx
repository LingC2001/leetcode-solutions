---
title: 11. Container With Most Water
---

import Code from '@/components/Code';

## Problem Statement

Given the following problem, find the optimal solution.

You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the i-th line are at `(i, 0)` and `(i, height[i])`.

Find two lines that together with the x-axis form a container that holds the most water.

Return the maximum amount of water a container can store.

---

## Approach

The solution uses the **Two-Pointer Technique** to efficiently find the largest possible container.

### General Strategy:
- **Initialize two pointers:** One at the start and one at the end of the array.
- **Calculate the container size:** The amount of water a container can hold is determined by the shorter of the two lines multiplied by the distance between them.
- **Move the pointer of the shorter line:** To potentially find a taller line that may result in a larger container, always move the pointer pointing to the shorter line. Moving the taller line would only decrease the width without guaranteeing more height.
- **Continue until pointers meet:** The process stops when the two pointers cross.

### Why this is optimal:
- The brute-force solution would involve checking all possible pairs, which would take O(nÂ²) time. By using the two-pointer technique, the solution finds the maximum area in O(n) time by eliminating suboptimal possibilities with each pointer move.

---

## Complexity Analysis

**Time Complexity:** ** O(n), where n is the number of elements in the input list. Each element is visited at most once by either pointer.

**Space Complexity:** ** O(1), no extra space is used beyond a few variables.

---

## Solutions

### Python

<Code problemNumber={11} difficulty="medium" lang="python" />

### C++

<Code problemNumber={11} difficulty="medium" lang="cpp" />

### Java

<Code problemNumber={11} difficulty="medium" lang="java" />

---

## Key Insights

- Review the problem's constraints and examples carefully
- Consider edge cases in your solution
- Analyze the trade-offs between time and space complexity
