---
title: 78. Subsets
---

import Code from '@/components/Code';

## Problem Statement

Given a set of distinct integers, `nums`, return all possible subsets (the power set).

The solution set must not contain duplicate subsets. You may return the solution in any order.

---

## Approach

To generate all subsets we can use backtracking (depth‑first search) to explore decisions of including or
excluding each element. Starting with an empty path, at each index we either take the current number
or skip it, recursing until the end of the array. Every path visited represents a valid subset, and we
add a copy of it to the result.

- Begin with an empty result list containing the empty subset.
- Iterate through elements, and for each position perform a recursive call that either includes the
current element or moves on.
- Use a temporary `path` slice/list to build the current subset; copy it when adding to the
`res` to avoid mutations.
- The time complexity is O(2ⁿ) since each element has two choices, and space complexity is also
O(2ⁿ) for the output.

This backtracking framework can be easily implemented in most languages.

---

## Complexity Analysis

**Time Complexity:** **O(2ⁿ · n)** – each subset takes O(n) to copy and there are 2ⁿ subsets.

**Space Complexity:** **O(2ⁿ · n)** – the output list contains all subsets, each of average length n/2.

---

## Solutions

### Go

<Code problemNumber={78} difficulty="medium" lang="go" />

---

## Key Insights

- Recognize that subsets correspond to the power set; the number of subsets grows exponentially.
- Backtracking with a simple include/exclude decision suffices and naturally avoids duplicates
because input has distinct elements.
- Always copy the current path when appending to results to avoid later modifications.
- Recursive and iterative (bitmask) approaches are both valid; backtracking is usually clearer.
