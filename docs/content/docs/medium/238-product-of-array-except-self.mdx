import Code from '@/components/Code';

## Problem Statement

Given the following problem, find the optimal solution.

Given an integer array `nums`, return an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`.

You must solve it **without using division** and in O(n) time.

---

## Approach

The core idea is to calculate the product of all elements except for the current one without using division, which can be challenging when zeros are present.

To achieve this efficiently, the algorithm uses two passes to compute prefix and suffix products:

- **Prefix products:** For each position, calculate the product of all elements before it.
- **Suffix products:** For each position, calculate the product of all elements after it.

Once both prefix and suffix products are computed, the final product for any index can be obtained by multiplying the prefix product just before it with the suffix product just after it.

This method avoids recalculating products multiple times and handles edge cases naturally, such as zeros in the input. It runs in linear time with extra linear space for the prefix and suffix arrays.

---

## Complexity Analysis

**Time Complexity:** ** O(n), where n is the length of `nums`. The array is traversed multiple times, but all operations remain linear.

**Space Complexity:** ** O(n), due to the additional arrays used for prefix products, suffix products, and the result.

---

## Solutions

### Python

<Code problemNumber={238} difficulty="medium" lang="python" />

### C++

<Code problemNumber={238} difficulty="medium" lang="cpp" />

### Java

<Code problemNumber={238} difficulty="medium" lang="java" />

---

## Key Insights

- Review the problem's constraints and examples carefully
- Consider edge cases in your solution
- Analyze the trade-offs between time and space complexity
