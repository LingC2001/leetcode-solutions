---
title: 20. Valid Parentheses
difficulty: easy
tags: [stack, strings]
---

import Code from '@/components/Code';

## Problem Statement

Given a string `s` containing just `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid. An input string is valid if:
- Open brackets are closed by the same type of brackets.
- Open brackets are closed in the correct order.
- Every closing bracket has a corresponding open bracket.

[View on LeetCode →](https://leetcode.com/problems/valid-parentheses/)

---

## Examples

### Example 1

```
Input: s = "()"
Output: true
```

### Example 2

```
Input: s = "()[]{}"
Output: true
```

### Example 3

```
Input: s = "(]"
Output: false
```

### Example 4

```
Input: s = "([)]"
Output: false
```

---

## Approach

Use a **stack** to track opening brackets:

1. Define a mapping `pairs = {')': '(', ']': '[', '}': '{'}`.
2. Iterate over each character `c`:
   - If `c` is an opening bracket, push it onto the stack.
   - If `c` is a closing bracket, check that the stack is non-empty and `stack[-1] == pairs[c]`. If so, pop; otherwise return `false`.
3. Return `true` if the stack is empty at the end (all brackets matched).

---

## Complexity Analysis

**Time Complexity:** O(n), where n = len(s). Each character is pushed or popped at most once.

**Space Complexity:** O(n) in the worst case (all opening brackets).

---

## Solutions

### Python

<Code problemNumber={20} difficulty="easy" lang="python" />

### C++

<Code problemNumber={20} difficulty="easy" lang="cpp" />

### Java

<Code problemNumber={20} difficulty="easy" lang="java" />

---

## Key Insights

- The stack's LIFO order naturally enforces that the most recently opened bracket must be closed first.
- Return `false` immediately on any mismatch — no need to continue scanning.
- A non-empty stack at the end means unmatched opening brackets exist.
