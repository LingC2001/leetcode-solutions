---
title: 875. Koko Eating Bananas
difficulty: medium
tags: [binary-search, arrays]
---

import Code from '@/components/Code';

## Problem Statement

Koko loves to eat bananas. There are `n` piles of bananas, where pile `i` has `piles[i]` bananas. Guards leave for `h` hours. Koko can choose an eating speed `k` (bananas per hour). Each hour she picks one pile and eats `k` bananas from it. She wants to finish all bananas within `h` hours. Return the minimum integer `k` such that she can eat all bananas in at most `h` hours.

[View on LeetCode →](https://leetcode.com/problems/koko-eating-bananas/)

---

## Examples

### Example 1

```
Input: piles = [3, 6, 7, 11], h = 8
Output: 4
```

### Example 2

```
Input: piles = [30, 11, 23, 4, 20], h = 5
Output: 30
```

### Example 3

```
Input: piles = [30, 11, 23, 4, 20], h = 6
Output: 23
```

---

## Approach

Binary search on the eating speed `k`:

1. **Search space:** `left = 1`, `right = max(piles)`.
2. **Feasibility check:** For speed `mid`, compute `hours = sum(ceil(p / mid) for p in piles)`.
   - If `hours <= h`, the speed works — record it and try lower: `right = mid - 1`.
   - If `hours > h`, too slow — increase speed: `left = mid + 1`.
3. Return the smallest valid `k` found.

---

## Complexity Analysis

**Time Complexity:** O(n · log m), where n = number of piles and m = max pile size.

**Space Complexity:** O(1).

---

## Solutions

### Python

<Code problemNumber={875} difficulty="medium" lang="python" />

### C++

<Code problemNumber={875} difficulty="medium" lang="cpp" />

### Java

<Code problemNumber={875} difficulty="medium" lang="java" />

---

## Key Insights

- Binary search applies because the feasibility function is monotone: if speed `k` works, any speed `> k` also works.
- `ceil(p / k)` can be computed without floating-point as `(p + k - 1) // k`.
- The search space is `[1, max(piles)]` — eating faster than the largest pile never helps.
