---
title: 74. Search a 2D Matrix
difficulty: medium
tags: [binary-search, matrix]
---

import Code from '@/components/Code';

## Problem Statement

Given the following problem, find the optimal solution.

Write an efficient algorithm that searches for a value `target` in an `m x n` integer matrix. This matrix has the following properties:
1. Integers in each row are sorted in ascending order from left to right.
2. The first integer of each row is greater than the last integer of the previous row.

Return `true` if `target` is found in the matrix, and `false` otherwise.

---

## Approach

We treat the 2D matrix as a virtual 1D sorted array of length `m * n`, then apply binary search:

1. Compute total elements: `total = m * n`.
2. Initialize two pointers, `left = 0` and `right = total - 1`.
3. While `left <= right`:
   - Compute `mid = (left + right) // 2`.
   - Map `mid` back to 2D indices:
     * `row = mid // n`
     * `col = mid % n`
   - Compare `matrix[row][col]` with `target`:
     - If equal, return `true`.
     - If `target` is smaller, move `right = mid - 1`.
     - Otherwise, move `left = mid + 1`.
4. If the loop ends without finding the target, return `false`.

Key Decisions:
- Flattening avoids two-phase search (first row, then column) and gives a single log-time binary search.
- Space usage remains O(1) since no auxiliary array is built.

Alternative:
- A two-step binary search: first on the first column to locate the candidate row, then binary search within that row. This is also O(log m + log n), comparable in complexity.

Pattern Used:
- Binary Search on a virtual 1D representation.

---

## Complexity Analysis

**Time Complexity:** 

**Space Complexity:** 

---

## Solutions

### Python

<Code problemNumber={74} difficulty="medium" lang="python" />

### C++

<Code problemNumber={74} difficulty="medium" lang="cpp" />

### Java

<Code problemNumber={74} difficulty="medium" lang="java" />

---

## Key Insights

- Review the problem's constraints and examples carefully
- Consider edge cases in your solution
- Analyze the trade-offs between time and space complexity
