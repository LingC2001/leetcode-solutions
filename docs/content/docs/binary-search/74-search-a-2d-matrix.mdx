---
title: 74. Search a 2D Matrix
difficulty: medium
tags: [binary-search, matrix]
---

import Code from '@/components/Code';

## Problem Statement

Write an efficient algorithm that searches for a value `target` in an `m x n` integer matrix with the following properties:
1. Integers in each row are sorted from left to right.
2. The first integer of each row is greater than the last integer of the previous row.

Return `true` if `target` is found, `false` otherwise.

[View on LeetCode →](https://leetcode.com/problems/search-a-2d-matrix/)

---

## Examples

### Example 1

```
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
Output: true
```

### Example 2

```
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
Output: false
```

---

## Approach

Treat the 2D matrix as a virtual 1D sorted array of length `m * n`, then apply binary search:

1. `left = 0`, `right = m * n - 1`.
2. While `left <= right`:
   - `mid = (left + right) // 2`
   - Map `mid` to 2D: `row = mid // n`, `col = mid % n`
   - If `matrix[row][col] == target`, return `true`.
   - If `< target`, set `left = mid + 1`.
   - If `> target`, set `right = mid - 1`.
3. Return `false` if not found.

This works because the row-first ordering guarantees a globally sorted 1D sequence.

---

## Complexity Analysis

**Time Complexity:** O(log(m * n)) = O(log m + log n).

**Space Complexity:** O(1).

---

## Solutions

### Python

<Code problemNumber={74} difficulty="medium" lang="python" />

### C++

<Code problemNumber={74} difficulty="medium" lang="cpp" />

### Java

<Code problemNumber={74} difficulty="medium" lang="java" />

---

## Key Insights

- The two matrix properties together guarantee a globally sorted 1D view — enabling a single binary search.
- The index mapping `row = mid // n`, `col = mid % n` is the key trick to flatten 2D into 1D.
- A two-step approach (binary search on rows, then on columns) also works but is slightly more code.
