---
title: 704. Binary Search
difficulty: easy
tags: [binary-search, arrays]
---

import Code from '@/components/Code';

## Problem Statement

Given an array of integers `nums` which is sorted in ascending order, and an integer `target`, return the index of `target` if it is in the array. If it is not present, return `-1`. You must write an algorithm with `O(log n)` runtime complexity.

[View on LeetCode →](https://leetcode.com/problems/binary-search/)

---

## Examples

### Example 1

```
Input: nums = [-1, 0, 3, 5, 9, 12], target = 9
Output: 4
Explanation: 9 exists in nums at index 4.
```

### Example 2

```
Input: nums = [-1, 0, 3, 5, 9, 12], target = 2
Output: -1
Explanation: 2 does not exist in nums so return -1.
```

---

## Approach

This problem is a classic application of the **Binary Search** algorithm.
* Begin with two pointers: `left = 0`, `right = len(nums) - 1`.
* At each step, calculate `mid = (left + right) // 2`.
* If `nums[mid] == target`, return `mid`.
* If `nums[mid] > target`, move `right = mid - 1`.
* If `nums[mid] < target`, move `left = mid + 1`.
* If the window collapses without finding target, return `-1`.

Binary search exploits the sorted ordering to eliminate half the remaining elements with each comparison.

---

## Complexity Analysis

**Time Complexity:** O(log n), since the search space is halved on each iteration.

**Space Complexity:** O(1), constant memory.

---

## Solutions

### Python

<Code problemNumber={704} difficulty="easy" lang="python" />

### C++

<Code problemNumber={704} difficulty="easy" lang="cpp" />

---

## Key Insights

- The sorted property is the prerequisite — binary search cannot be applied to unsorted arrays.
- Use `mid = left + (right - left) // 2` to avoid integer overflow in languages like C++/Java.
- Every iteration must strictly shrink the window to avoid infinite loops.
