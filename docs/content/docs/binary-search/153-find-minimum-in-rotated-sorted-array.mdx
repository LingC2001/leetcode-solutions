---
title: 153. Find Minimum in Rotated Sorted Array
difficulty: medium
tags: [binary-search, arrays]
---

import Code from '@/components/Code';

## Problem Statement

Given the following problem, find the optimal solution.



---

## Approach

We use a modified **Binary Search** (Two Pointers pattern) to achieve O(log n) time:

1. Initialize two pointers:
   - `left = 0`
   - `right = len(nums) - 1`

2. While `left < right`:
   - Compute `mid = (left + right) // 2`.
   - Compare `nums[mid]` with `nums[right]`:
     - If `nums[mid] < nums[right]`, the minimum lies in the left half (including `mid`), so set `right = mid`.
     - Else (`nums[mid] >= nums[right]`), the minimum lies in the right half (excluding `mid`), so set `left = mid + 1`.

3. When `left == right`, the loop ends and `nums[left]` is the minimum.

This works because in a rotated sorted array, one half is always in proper ascending order, and the pivot (minimum) lies in the other half.

**Why this is optimal:**  
- We discard half of the search space at each step, guaranteeing O(log n) runtime.  
- We use only constant extra space.

**Alternative (Brute-Force):**  
Scan the entire array in O(n) time to find the minimum. This is simpler but does not meet the O(log n) requirement.

---

## Complexity Analysis

**Time Complexity:** O(log n), where n = len(nums).  

**Space Complexity:** O(1), only pointers and indices are used.

---

## Solutions

### Python

<Code problemNumber={153} difficulty="medium" lang="python" />

### C++

<Code problemNumber={153} difficulty="medium" lang="cpp" />

---

## Key Insights

- Review the problem's constraints and examples carefully
- Consider edge cases in your solution
- Analyze the trade-offs between time and space complexity
