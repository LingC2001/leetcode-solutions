---
title: 153. Find Minimum in Rotated Sorted Array
difficulty: medium
tags: [binary-search, arrays]
---

import Code from '@/components/Code';

## Problem Statement

Suppose an array of length `n` sorted in ascending order is rotated between 1 and `n` times. Given the rotated array `nums`, return the minimum element. You must write an algorithm that runs in O(log n) time.

[View on LeetCode →](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)

---

## Examples

### Example 1

```
Input: nums = [3, 4, 5, 1, 2]
Output: 1
Explanation: The original array was [1, 2, 3, 4, 5] rotated 3 times.
```

### Example 2

```
Input: nums = [4, 5, 6, 7, 0, 1, 2]
Output: 0
```

### Example 3

```
Input: nums = [11, 13, 15, 17]
Output: 11
Explanation: The array was not rotated (0 times).
```

---

## Approach

We use a modified **Binary Search** to achieve O(log n) time:

1. Initialize `left = 0`, `right = len(nums) - 1`.
2. While `left < right`:
   - Compute `mid = (left + right) // 2`.
   - If `nums[mid] < nums[right]`, the minimum lies in the left half (including `mid`), so set `right = mid`.
   - Else, the minimum lies in the right half (excluding `mid`), so set `left = mid + 1`.
3. When `left == right`, `nums[left]` is the minimum.

In a rotated sorted array, one half is always properly sorted. Comparing `nums[mid]` to `nums[right]` tells us which half contains the pivot (minimum).

---

## Complexity Analysis

**Time Complexity:** O(log n), where n = len(nums).

**Space Complexity:** O(1).

---

## Solutions

### Python

<Code problemNumber={153} difficulty="medium" lang="python" />

### C++

<Code problemNumber={153} difficulty="medium" lang="cpp" />

---

## Key Insights

- Compare `nums[mid]` to `nums[right]` (not `nums[left]`) to determine which half contains the minimum.
- The pivot is always in the "unsorted" half — the half where ordinality breaks.
- Handles non-rotated arrays naturally since in that case `nums[mid] < nums[right]` always.
