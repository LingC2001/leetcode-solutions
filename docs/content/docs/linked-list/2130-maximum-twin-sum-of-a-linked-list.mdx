---
title: 2130. Maximum Twin Sum of a Linked List
difficulty: medium
tags: [linked-list, two-pointers, stack]
---

import Code from '@/components/Code';

## Problem Statement

Given the following problem, find the optimal solution.

In a linked list of even length, the **twin** of the node at index `i` (0-indexed) is the node at index `n - 1 - i`, where `n` is the length of the linked list.

The **twin sum** is defined as the sum of a node and its twin.

Given the `head` of a linked list with even length, return the **maximum twin sum** of the linked list.

---

## Approach

To efficiently compute the maximum twin sum, we need to pair:

- First node with last node  
- Second node with second-last node  
- And so on...

### Optimal Strategy (Fast & Slow Pointer + Reverse Second Half)

1. **Find the middle of the linked list** using the fast and slow pointer technique.
   - `fast` moves two steps at a time.
   - `slow` moves one step at a time.
   - When `fast` reaches the end, `slow` is at the midpoint.

2. **Reverse the second half** of the linked list starting from `slow`.

3. **Traverse both halves simultaneously**, computing:
```
twin_sum = first_half_node.val + second_half_node.val
```

Keep track of the maximum twin sum during traversal.

4. Return the maximum twin sum found.

---

## Complexity Analysis

**Time Complexity:** O(n), where `n` is the number of nodes in the list.  
- Finding the middle → O(n)  
- Reversing half → O(n)  
- Calculating twin sums → O(n)

**Space Complexity:** O(1)  
- We reverse the list in-place without using extra space.

---

## Solutions

### Go

<Code problemNumber={2130} difficulty="medium" lang="go" />

---

## Key Insights

- Linked list problems often benefit from the fast & slow pointer technique.
- Reversing part of a linked list is a powerful tool for pairing symmetrical nodes.
- Always check whether in-place modification is allowed to optimize space.
- Since the list length is guaranteed to be even, no extra edge-case handling is required for unmatched nodes.