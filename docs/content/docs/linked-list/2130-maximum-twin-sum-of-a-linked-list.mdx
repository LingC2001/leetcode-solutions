---
title: 2130. Maximum Twin Sum of a Linked List
difficulty: medium
tags: [linked-list, two-pointers, stack]
---

import Code from '@/components/Code';

## Problem Statement

In a linked list of even length `n`, the **twin** of node `i` is node `n - 1 - i`. The **twin sum** is the sum of a node and its twin. Given the head of a linked list with even length, return the **maximum twin sum**.

[View on LeetCode →](https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/)

---

## Examples

### Example 1

```
Input: head = [5, 4, 2, 1]
Output: 6
Explanation: Nodes 0 and 3 are twins (5+1=6), nodes 1 and 2 are twins (4+2=6). Max twin sum = 6.
```

### Example 2

```
Input: head = [4, 2, 2, 3]
Output: 7
Explanation: Twins: (4,3)=7, (2,2)=4. Max = 7.
```

### Example 3

```
Input: head = [1, 100000]
Output: 100001
```

---

## Approach

**Fast & Slow Pointer + Reverse Second Half:**

1. Find the middle using fast/slow pointers (`slow` moves 1 step, `fast` moves 2 steps).
2. Reverse the second half of the list in-place starting from `slow`.
3. Traverse both halves simultaneously, computing `twin_sum = first.val + second.val` at each step.
4. Return the maximum twin sum.

This avoids allocating extra arrays and works in O(1) space.

---

## Complexity Analysis

**Time Complexity:** O(n) — finding middle + reversing half + scanning both halves.

**Space Complexity:** O(1) — in-place reversal.

---

## Solutions

### Go

<Code problemNumber={2130} difficulty="medium" lang="go" />

---

## Key Insights

- The fast/slow pointer trick finds the midpoint in one pass without knowing list length upfront.
- Reversing the second half turns the symmetric pairing problem into a simple two-pointer scan.
- Always check whether in-place modification is allowed — an alternative O(n) space approach uses a stack or array.
