---
title: 206. Reverse Linked List
difficulty: easy
tags: [linked-list]
---

import Code from '@/components/Code';

## Problem Statement

Given the head of a singly linked list, reverse the list and return the reversed list.

[View on LeetCode →](https://leetcode.com/problems/reverse-linked-list/)

---

## Examples

### Example 1

```
Input: head = [1, 2, 3, 4, 5]
Output: [5, 4, 3, 2, 1]
```

### Example 2

```
Input: head = [1, 2]
Output: [2, 1]
```

### Example 3

```
Input: head = []
Output: []
```

---

## Approach

In-place iterative reversal with two pointers:

1. Initialize `prev = None`, `current = head`.
2. While `current != None`:
   - Save `next_node = current.next`.
   - Reverse the link: `current.next = prev`.
   - Advance: `prev = current`, `current = next_node`.
3. Return `prev` — the new head.

Only `next` pointers are modified; no new nodes are created.

---

## Complexity Analysis

**Time Complexity:** O(n), where n is the number of nodes.

**Space Complexity:** O(1) for the iterative approach. Recursive approach is O(n) call stack.

---

## Solutions

### Python

<Code problemNumber={206} difficulty="easy" lang="python" />

### C++

<Code problemNumber={206} difficulty="easy" lang="cpp" />

### Java

<Code problemNumber={206} difficulty="easy" lang="java" />

---

## Key Insights

- Three variables (`prev`, `current`, `next_node`) are all that is needed — no extra data structure.
- Always save `current.next` before overwriting it, otherwise the rest of the list is lost.
- Recursive reversal is elegant but uses O(n) stack space; prefer iterative for large inputs.
