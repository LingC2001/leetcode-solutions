---
title: 15. 3Sum
difficulty: medium
tags: [two-pointers, arrays, sorting]
---

import Code from '@/components/Code';

## Problem Statement

Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, `j != k`, and `nums[i] + nums[j] + nums[k] == 0`. The solution set must not contain duplicate triplets.

[View on LeetCode →](https://leetcode.com/problems/3sum/)

---

## Examples

### Example 1

```
Input: nums = [-1, 0, 1, 2, -1, -4]
Output: [[-1, -1, 2], [-1, 0, 1]]
```

### Example 2

```
Input: nums = [0, 1, 1]
Output: []
```

### Example 3

```
Input: nums = [0, 0, 0]
Output: [[0, 0, 0]]
```

---

## Approach

Sort + Two Pointers:

1. **Sort the array.**
2. Iterate with index `i` as the first element.
   - Skip `nums[i]` if it equals `nums[i-1]` to avoid duplicate triplets.
   - If `nums[i] > 0`, break — no triplet can sum to 0.
3. For each `i`, use two pointers `lo = i+1`, `hi = n-1`:
   - If `sum == 0`: record the triplet, skip duplicate values at `lo` and `hi`, advance both pointers.
   - If `sum < 0`: increment `lo`.
   - If `sum > 0`: decrement `hi`.

---

## Complexity Analysis

**Time Complexity:** O(n²) — O(n log n) sort + O(n²) two-pointer sweeps.

**Space Complexity:** O(1) excluding the output list.

---

## Solutions

### Python

<Code problemNumber={15} difficulty="medium" lang="python" />

### C++

<Code problemNumber={15} difficulty="medium" lang="cpp" />

### Java

<Code problemNumber={15} difficulty="medium" lang="java" />

---

## Key Insights

- Sorting is essential: it enables two pointers and makes duplicate skipping straightforward.
- Skip duplicate values of `nums[i]` at the outer loop, and skip duplicates of `lo`/`hi` after recording a triplet.
- Early `break` when `nums[i] > 0` is a correctness optimization — a sorted array can't form a zero-sum triplet past this point.
