---
title: 167. Two Sum II - Input Array Is Sorted
difficulty: medium
tags: [two-pointers, arrays, binary-search]
---

import Code from '@/components/Code';

## Problem Statement

Given a 1-indexed array of integers `numbers` sorted in non-decreasing order, find two numbers that add up to `target`. Return their indices as `[index1, index2]` (1-indexed). Each input has exactly one solution, and you may not use the same element twice. Use only constant extra space.

[View on LeetCode →](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)

---

## Examples

### Example 1

```
Input: numbers = [2, 7, 11, 15], target = 9
Output: [1, 2]
Explanation: numbers[1] + numbers[2] = 2 + 7 = 9.
```

### Example 2

```
Input: numbers = [2, 3, 4], target = 6
Output: [1, 3]
```

### Example 3

```
Input: numbers = [-1, 0], target = -1
Output: [1, 2]
```

---

## Approach

Two-pointer leveraging the sorted property:

1. `left = 0`, `right = n - 1`.
2. Compute `sum = numbers[left] + numbers[right]`.
   - If `sum == target`: return `[left + 1, right + 1]`.
   - If `sum > target`: decrement `right` to reduce the sum.
   - If `sum < target`: increment `left` to increase the sum.

Because exactly one solution exists, the pointers will always converge to it.

---

## Complexity Analysis

**Time Complexity:** O(n), where n is the length of `numbers`.

**Space Complexity:** O(1).

---

## Solutions

### Python

<Code problemNumber={167} difficulty="medium" lang="python" />

### C++

<Code problemNumber={167} difficulty="medium" lang="cpp" />

### Java

<Code problemNumber={167} difficulty="medium" lang="java" />

---

## Key Insights

- The sorted order guarantees that moving `left` right increases the sum and moving `right` left decreases it — the two-pointer approach is provably correct.
- This achieves O(n) vs O(n log n) for binary search per element, and O(1) space vs a hash map approach.
- The problem guarantees exactly one solution, so no "not found" case needs to be handled.
