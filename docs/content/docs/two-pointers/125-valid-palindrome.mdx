---
title: 125. Valid Palindrome
difficulty: easy
tags: [two-pointers, strings]
---

import Code from '@/components/Code';

## Problem Statement

A phrase is a palindrome if, after converting all uppercase letters to lowercase and removing all non-alphanumeric characters, it reads the same forward and backward. Given a string `s`, return `true` if it is a palindrome, or `false` otherwise.

[View on LeetCode →](https://leetcode.com/problems/valid-palindrome/)

---

## Examples

### Example 1

```
Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.
```

### Example 2

```
Input: s = "race a car"
Output: false
Explanation: "raceacar" is not a palindrome.
```

### Example 3

```
Input: s = " "
Output: true
Explanation: After removing non-alphanumeric characters, it's an empty string, which is a palindrome.
```

---

## Approach

1. Preprocess: convert `s` to lowercase and filter to alphanumeric characters only → `stripped`.
2. Use two pointers `left = 0`, `right = len(stripped) - 1`.
3. While `left < right`:
   - If `stripped[left] != stripped[right]`, return `false`.
   - Advance both pointers inward.
4. Return `true`.

---

## Complexity Analysis

**Time Complexity:** O(n), where n is the length of `s`. Filtering and checking are both linear.

**Space Complexity:** O(n) for the filtered string. An in-place two-pointer variant using `isalnum` skips filtering to achieve O(1) space.

---

## Solutions

### Python

<Code problemNumber={125} difficulty="easy" lang="python" />

### C++

<Code problemNumber={125} difficulty="easy" lang="cpp" />

### Java

<Code problemNumber={125} difficulty="easy" lang="java" />

---

## Key Insights

- Preprocessing simplifies the comparison logic — handle case and non-alphanumeric filtering once upfront.
- O(1) space variant: skip non-alphanumeric characters directly in the two-pointer loop without building a filtered string.
- An empty or single-character string (after filtering) is trivially a palindrome.
