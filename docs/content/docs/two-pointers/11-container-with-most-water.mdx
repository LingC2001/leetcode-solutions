---
title: 11. Container With Most Water
difficulty: medium
tags: [two-pointers, arrays, greedy]
---

import Code from '@/components/Code';

## Problem Statement

You are given an integer array `height` of length `n`. There are `n` vertical lines where the two endpoints of line `i` are at `(i, 0)` and `(i, height[i])`. Find two lines that together with the x-axis form a container that holds the most water. Return the maximum amount of water the container can store.

[View on LeetCode →](https://leetcode.com/problems/container-with-most-water/)

---

## Examples

### Example 1

```
Input: height = [1, 8, 6, 2, 5, 4, 8, 3, 7]
Output: 49
Explanation: Lines at index 1 (height 8) and index 8 (height 7) form the container: min(8,7) * (8-1) = 7*7 = 49.
```

### Example 2

```
Input: height = [1, 1]
Output: 1
```

---

## Approach

**Two-pointer technique:**

1. Initialize `left = 0`, `right = n - 1`.
2. At each step, compute `area = min(height[left], height[right]) * (right - left)` and update `max_area`.
3. Move the pointer pointing to the **shorter** line inward — moving the taller line can only decrease the width without guaranteed height gain.
4. Stop when pointers meet.

---

## Complexity Analysis

**Time Complexity:** O(n), each element is visited at most once.

**Space Complexity:** O(1).

---

## Solutions

### Python

<Code problemNumber={11} difficulty="medium" lang="python" />

### C++

<Code problemNumber={11} difficulty="medium" lang="cpp" />

### Java

<Code problemNumber={11} difficulty="medium" lang="java" />

---

## Key Insights

- Always move the pointer at the shorter wall — the current area is already bottlenecked by the shorter wall, so keeping it can only maintain or decrease area.
- The greedy choice is provably optimal: no unvisited pair can beat the best found.
- Brute force is O(n²); two pointers reduces this to O(n) by eliminating dominated pairs.
