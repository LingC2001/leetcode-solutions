---
title: 567. Permutation in String
difficulty: medium
tags: [sliding-window, strings, hashing]
---

import Code from '@/components/Code';

## Problem Statement

Given two strings `s1` and `s2`, return `true` if `s2` contains a **permutation** of `s1`, otherwise return `false`. In other words, check if one of `s1`'s permutations is a substring of `s2`.

[View on LeetCode →](https://leetcode.com/problems/permutation-in-string/)

---

## Examples

### Example 1

```
Input: s1 = "ab", s2 = "eidbaooo"
Output: true
Explanation: s2 contains "ba" which is a permutation of s1.
```

### Example 2

```
Input: s1 = "ab", s2 = "eidboaoo"
Output: false
```

---

## Approach

**Fixed-size sliding window** of length `len(s1)`:

* If `len(s1) > len(s2)`, return `false`.
* Build frequency maps for `s1` and the first window `s2[0:len(s1)]`.
* Slide the window across `s2`:
  * Add the new character's count, remove the outgoing character's count.
  * Clean up zero-count entries so direct dictionary comparison works.
  * If the two maps are equal, return `true`.
* Return `false` if no match found.

---

## Complexity Analysis

**Time Complexity:** O(n), where n is the length of `s2`. Each character is processed once.

**Space Complexity:** O(1), since the character set is at most 26 lowercase letters.

---

## Solutions

### Python

<Code problemNumber={567} difficulty="medium" lang="python" />

### C++

<Code problemNumber={567} difficulty="medium" lang="cpp" />

### Java

<Code problemNumber={567} difficulty="medium" lang="java" />

---

## Key Insights

- A permutation has identical character frequencies — comparing frequency maps is the correct check.
- Remove zero-count entries from the map to ensure equality comparisons work correctly.
- Alternatively, maintain a `matches` counter to avoid full map comparison on every step (O(1) check per slide).
