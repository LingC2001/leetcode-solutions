---
title: 1. Two Sum
difficulty: easy
tags: [arrays, hashing]
---

import Code from '@/components/Code';

## Problem Statement

Given the following problem, find the optimal solution.

Given an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.

---

## Approach

The solution uses a hash map (dictionary) to store the values and their indices as we iterate through the list. For each element `nums[i]`, it checks whether `target - nums[i]` has already been seen. If so, the pair of indices that add up to `target` is returned immediately. Otherwise, the current number and its index are stored in the dictionary for future reference.

- We iterate through the list once.
- Use a dictionary to look up complements in O(1) time.
- Return indices as soon as the pair is found.
- This approach is optimal for time complexity compared to brute force, which would check all pairs (O(nÂ²)).

---

## Complexity Analysis

**Time Complexity:** ** O(n), where n is the length of `nums`. Each element is visited once, and dictionary lookups are O(1).

**Space Complexity:** ** O(n), as extra space is used to store elements in the dictionary.

---

## Solutions

### Python

<Code problemNumber={1} difficulty="easy" lang="python" />

### C++

<Code problemNumber={1} difficulty="easy" lang="cpp" />

### Java

<Code problemNumber={1} difficulty="easy" lang="java" />

### Go

<Code problemNumber={1} difficulty="easy" lang="go" />

---

## Key Insights

- Review the problem's constraints and examples carefully
- Consider edge cases in your solution
- Analyze the trade-offs between time and space complexity
