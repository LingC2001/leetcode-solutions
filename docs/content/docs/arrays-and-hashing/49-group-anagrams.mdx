---
title: 49. Group Anagrams
difficulty: medium
tags: [arrays, hashing, strings, sorting]
---

import Code from '@/components/Code';

## Problem Statement

Given an array of strings `strs`, group the anagrams together. You can return the answer in any order. An anagram is a word formed by rearranging the letters of a different word, using all the original letters exactly once.

[View on LeetCode →](https://leetcode.com/problems/group-anagrams/)

---

## Examples

### Example 1

```
Input: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
Output: [["bat"], ["nat", "tan"], ["ate", "eat", "tea"]]
```

### Example 2

```
Input: strs = [""]
Output: [[""]]
```

### Example 3

```
Input: strs = ["a"]
Output: [["a"]]
```

---

## Approach

To group anagrams efficiently, leverage the fact that anagrams share the same character frequency signature.

Instead of sorting each string (which takes O(k log k) per string), build a fixed-size character count array of length 26, then use it as a dictionary key:
- For each string, compute a count array of alphabet letter frequencies.
- Use this count array (converted to a tuple) as the hash map key.
- Group strings with the same signature together.
- Return all grouped lists.

---

## Complexity Analysis

**Time Complexity:** O(n · k), where n is the number of strings and k is the maximum string length. Counting characters is O(k) per string.

**Space Complexity:** O(n · k), to store grouped anagrams and their frequency signatures.

---

## Solutions

### Python

<Code problemNumber={49} difficulty="medium" lang="python" />

### C++

<Code problemNumber={49} difficulty="medium" lang="cpp" />

### Java

<Code problemNumber={49} difficulty="medium" lang="java" />

---

## Key Insights

- The character-count key avoids O(k log k) per string sorting, reducing to O(k) per string.
- A tuple of 26 counts is a hashable, canonical representation of any anagram group.
- `defaultdict(list)` or equivalent simplifies appending to groups without checking for key existence.
