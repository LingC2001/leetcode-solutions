---
title: 53. Maximum Subarray
difficulty: medium
tags: [arrays, dynamic-programming]
---

import Code from '@/components/Code';

## Problem Statement

Given an integer array `nums`, find the subarray with the largest sum, and return its sum.

[View on LeetCode →](https://leetcode.com/problems/maximum-subarray/)

---

## Examples

### Example 1

```
Input: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
Output: 6
Explanation: The subarray [4, -1, 2, 1] has the largest sum 6.
```

### Example 2

```
Input: nums = [1]
Output: 1
```

### Example 3

```
Input: nums = [5, 4, -1, 7, 8]
Output: 23
```

---

## Approach

This is solved with **Kadane's Algorithm** — a classic greedy/dynamic programming approach:

- Maintain a running sum `current`. If `current` drops below 0, reset it to the current element (a negative prefix only hurts future subarrays).
- Track `max_sum` across all positions.
- One pass through the array is sufficient.

```
current = nums[0], max_sum = nums[0]
for i in 1..n-1:
    if current < 0: current = nums[i]
    else:           current += nums[i]
    max_sum = max(max_sum, current)
```

---

## Complexity Analysis

**Time Complexity:** O(n), where n is the length of `nums`. A single pass through the array.

**Space Complexity:** O(1), only two variables are maintained.

---

## Solutions

### Go

<Code problemNumber={53} difficulty="medium" lang="go" />

---

## Key Insights

- If the running sum ever goes negative, discard the entire prefix — no negative prefix can help maximize a subarray starting later.
- Kadane's algorithm is both a greedy and DP approach: `dp[i] = max(nums[i], dp[i-1] + nums[i])`.
- The all-negative edge case is handled naturally since `max_sum` is initialized to `nums[0]`.
