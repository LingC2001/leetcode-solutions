---
title: 238. Product of Array Except Self
difficulty: medium
tags: [arrays, prefix-sum]
---

import Code from '@/components/Code';

## Problem Statement

Given an integer array `nums`, return an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`. You must solve it **without using division** and in O(n) time.

[View on LeetCode →](https://leetcode.com/problems/product-of-array-except-self/)

---

## Examples

### Example 1

```
Input: nums = [1, 2, 3, 4]
Output: [24, 12, 8, 6]
```

### Example 2

```
Input: nums = [-1, 1, 0, -3, 3]
Output: [0, 0, 9, 0, 0]
```

---

## Approach

The core idea is to compute the product of all elements except the current one without division. This is done using two passes — prefix and suffix products:

- **Prefix products:** For each position `i`, compute the product of all elements **before** it.
- **Suffix products:** For each position `i`, compute the product of all elements **after** it.

The final answer at index `i` is `prefix[i] * suffix[i]`.

**Optimized (O(1) extra space):** Build the prefix into the result array, then apply the suffix product in a reverse pass using a running variable.

---

## Complexity Analysis

**Time Complexity:** O(n), where n is the length of `nums`. The array is traversed twice.

**Space Complexity:** O(1) extra space (the output array does not count toward space complexity).

---

## Solutions

### Python

<Code problemNumber={238} difficulty="medium" lang="python" />

### C++

<Code problemNumber={238} difficulty="medium" lang="cpp" />

### Java

<Code problemNumber={238} difficulty="medium" lang="java" />

---

## Key Insights

- Division is forbidden — prefix/suffix products are the standard workaround.
- Two arrays can be merged into one by first filling in prefix products, then multiplying by a running suffix from right to left.
- This is a prime example of using auxiliary information computed in separate passes to avoid O(n²) nested loops.
