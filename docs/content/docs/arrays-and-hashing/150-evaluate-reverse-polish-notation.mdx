---
title: 150. Evaluate Reverse Polish Notation
difficulty: medium
tags: [stack, math]
---

import Code from '@/components/Code';

## Problem Statement

You are given an array of strings `tokens` that represents an arithmetic expression in Reverse Polish Notation (RPN). Evaluate the expression and return its value. Valid operators are `+`, `-`, `*`, and `/`. Each operand may be an integer or another expression. Division between two integers should truncate toward zero.

[View on LeetCode →](https://leetcode.com/problems/evaluate-reverse-polish-notation/)

---

## Examples

### Example 1

```
Input: tokens = ["2", "1", "+", "3", "*"]
Output: 9
Explanation: ((2 + 1) * 3) = 9
```

### Example 2

```
Input: tokens = ["4", "13", "5", "/", "+"]
Output: 6
Explanation: (4 + (13 / 5)) = 6
```

### Example 3

```
Input: tokens = ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]
Output: 22
```

---

## Approach

We use a stack to evaluate the RPN expression in one pass:

1. Initialize an empty stack.
2. Iterate through each token in `tokens`:
   - If the token is a number, convert it to `int` and push it onto the stack.
   - Otherwise, it is an operator:
     - Pop the top two numbers from the stack (`b` first, then `a`).
     - Apply the operator to `a` and `b` and push the result.
     - For `/`, use `int(a / b)` to truncate toward zero.
3. After processing all tokens, the stack contains a single element: the result.

---

## Complexity Analysis

**Time Complexity:** O(n), where n is the number of tokens. Each token is processed once.

**Space Complexity:** O(n), for the stack in the worst case (all tokens are numbers).

---

## Solutions

### Python

<Code problemNumber={150} difficulty="medium" lang="python" />

### C++

<Code problemNumber={150} difficulty="medium" lang="cpp" />

### Java

<Code problemNumber={150} difficulty="medium" lang="java" />

---

## Key Insights

- RPN eliminates the need for parentheses and operator precedence rules — a stack naturally handles evaluation order.
- Pop operands in reverse: pop `b` then `a` so that `a OP b` is computed correctly.
- For integer division truncating toward zero, use `int(a / b)` in Python (not `a // b` which rounds toward negative infinity).
