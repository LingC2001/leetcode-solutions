---
title: 121. Best Time to Buy and Sell Stock
difficulty: easy
tags: [greedy, arrays]
---

import Code from '@/components/Code';

## Problem Statement

You are given an array `prices` where `prices[i]` is the price of a given stock on the `i`-th day. You want to maximize your profit by choosing a **single day to buy** one stock and a **different day in the future to sell** it. Return the maximum profit you can achieve. If no profit is possible, return `0`.

[View on LeetCode →](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)

---

## Examples

### Example 1

```
Input: prices = [7, 1, 5, 3, 6, 4]
Output: 5
Explanation: Buy on day 2 (price=1), sell on day 5 (price=6), profit = 5.
```

### Example 2

```
Input: prices = [7, 6, 4, 3, 1]
Output: 0
Explanation: Prices only decrease — no profitable transaction possible.
```

---

## Approach

Single-pass greedy:
* Track the lowest price seen so far (`min_price`).
* At each day, compute `profit = price - min_price` and update `max_profit`.
* Update `min_price` if the current price is lower.

This guarantees that the "buy before sell" constraint is always satisfied.

---

## Complexity Analysis

**Time Complexity:** O(n), where n is the number of days.

**Space Complexity:** O(1).

---

## Solutions

### Python

<Code problemNumber={121} difficulty="easy" lang="python" />

### C++

<Code problemNumber={121} difficulty="easy" lang="cpp" />

### Java

<Code problemNumber={121} difficulty="easy" lang="java" />

---

## Key Insights

- Tracking the running minimum implicitly handles the "buy before sell" ordering constraint.
- If all prices are decreasing, `max_profit` stays 0 — the base value handles this edge case naturally.
- This is equivalent to Kadane's algorithm applied to the difference array of prices.
