---
title: 20. Valid Parentheses
---

import Code from '@/components/Code';

## Problem Statement

Given the following problem, find the optimal solution.

Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid. An input string is valid if:

- Open brackets are closed by the same type of brackets.
- Open brackets are closed in the correct order.
- Every closing bracket has a corresponding open bracket of the same type.

---

## Approach

We employ a **Stack** to track opening brackets and verify matches with closing brackets:

1. Define a mapping `pairs` for closing→opening:
   ```python
   pairs = {')': '(', ']': '[', '}': '{'}
   ```
2. Initialize an empty stack `stack = []`.
3. Iterate over each character `c` in `s`:
   - If `c` is not in `pairs` (i.e., it's an opening bracket), push it onto `stack`.
   - Else (`c` is a closing bracket):
     - Check if `stack` is non-empty and `stack[-1] == pairs[c]`.  
       - If yes, pop the stack.
       - Otherwise, return `False` immediately (mismatch or no opening bracket).
4. After processing all characters, return `True` if `stack` is empty (all brackets matched); otherwise, `False`.

Why this works:
- The stack’s LIFO order ensures the most recent opening bracket is closed first.
- Immediate failure on mismatch or missing opening bracket.

Alternative approaches:
- Recursive parsing can also validate pairs but is less direct and uses call-stack.
- Repeated string replacement of valid pairs is O(n²), so suboptimal.

---

## Complexity Analysis

**Time Complexity:** O(n), where n = len(s). Each character is pushed or popped at most once.

**Space Complexity:** O(n) in the worst case, for the stack holding all opening brackets.

---

## Solutions

### Python

<Code problemNumber={20} difficulty="easy" lang="python" />

### C++

<Code problemNumber={20} difficulty="easy" lang="cpp" />

### Java

<Code problemNumber={20} difficulty="easy" lang="java" />

---

## Key Insights

- Review the problem's constraints and examples carefully
- Consider edge cases in your solution
- Analyze the trade-offs between time and space complexity
