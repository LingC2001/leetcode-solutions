---
title: 206. Reverse Linked List
---

import Code from '@/components/Code';

## Problem Statement

Given the following problem, find the optimal solution.

Given the head of a singly linked list, reverse the list and return the reversed list.

---

## Approach

We use an **in-place iterative reversal** with the Two Pointers pattern:

1. Initialize two pointers:
   - `prev = None`
   - `current = head`
2. Iterate until `current` becomes `None`:
   - Save `next_node = current.next`
   - Reverse the link: `current.next = prev`
   - Move `prev` forward: `prev = current`
   - Move `current` forward: `current = next_node`
3. At the end, `prev` points to the new head of the reversed list. Return `prev`.

Key points:
- We only change the `next` pointers; no new nodes are created.
- This uses constant extra space.
- Alternative approach: recursive reversal, but it uses O(n) call stack.

---

## Complexity Analysis

**Time Complexity:** ** O(n), where n is the number of nodes. Each node is visited exactly once.

**Space Complexity:** ** O(1), since we only use a fixed number of pointers.

---

## Solutions

### Python

<Code problemNumber={206} difficulty="easy" lang="python" />

### C++

<Code problemNumber={206} difficulty="easy" lang="cpp" />

### Java

<Code problemNumber={206} difficulty="easy" lang="java" />

---

## Key Insights

- Review the problem's constraints and examples carefully
- Consider edge cases in your solution
- Analyze the trade-offs between time and space complexity
