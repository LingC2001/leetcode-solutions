---
title: 39. Combination Sum
difficulty: medium
tags: [backtracking, arrays]
---

import Code from '@/components/Code';

## Problem Statement

Given an array of **distinct** integers `candidates` and a target integer `target`, return a list of all **unique combinations** of `candidates` where the chosen numbers sum to `target`. The same number may be chosen from `candidates` an unlimited number of times. You may return the answer in any order.

[View on LeetCode →](https://leetcode.com/problems/combination-sum/)

---

## Examples

### Example 1

```
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
```

### Example 2

```
Input: candidates = [2,3,5], target = 8
Output: [[2,2,2,2],[2,3,3],[3,5]]
```

---

## Approach

**Backtracking (DFS):**

At each step, iterate over candidates starting from `index` to avoid re-using earlier elements in a different order (which would create duplicate combinations). Add the current candidate to the running sum and recurse. Because a candidate can be reused, pass `i` (not `i + 1`) as the next starting index. Backtrack by removing the last element after each recursive call.

```
backtrack(index, path, sum):
    if sum == target:
        result.append(copy of path)
        return
    if sum > target:
        return
    for i in index..n-1:
        path.append(candidates[i])
        backtrack(i, path, sum + candidates[i])
        path.pop()
```

The key difference from Subsets is that the same index `i` is passed on the recursive call, allowing repeated use of the same element.

---

## Complexity Analysis

**Time Complexity:** O(n^(T/M)) — where T is the target and M is the minimum candidate value. This bounds the depth and branching of the recursion tree.

**Space Complexity:** O(T/M) — maximum recursion depth is T divided by the smallest candidate.

---

## Solutions

### Go

<Code problemNumber={39} difficulty="medium" lang="go" />

---

## Key Insights

- Passing `i` (not `i + 1`) to the recursive call allows the same candidate to be reused.
- Starting the loop at `index` rather than `0` prevents duplicate combinations that differ only in ordering (e.g., `[2,3]` and `[3,2]`).
- Always copy the path before appending to results — slices share underlying arrays and mutations will corrupt stored combinations.
- Pruning when `sum > target` avoids unnecessary recursion and improves performance.
