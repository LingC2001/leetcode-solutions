---
title: 78. Subsets
difficulty: medium
tags: [backtracking, arrays]
---

import Code from '@/components/Code';

## Problem Statement

Given an integer array `nums` of **unique** elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. You may return the answer in any order.

[View on LeetCode →](https://leetcode.com/problems/subsets/)

---

## Examples

### Example 1

```
Input: nums = [1, 2, 3]
Output: [[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]
```

### Example 2

```
Input: nums = [0]
Output: [[], [0]]
```

---

## Approach

**Backtracking (DFS):**

Starting from an empty path, at each index make two decisions: include the current element, or skip it. Recurse until the end of the array. Every visited path is a valid subset.

```
dfs(index, path):
    result.append(copy of path)
    for i in index..n-1:
        path.append(nums[i])
        dfs(i + 1, path)
        path.pop()
```

Since all elements are distinct, no duplicate-skipping logic is needed.

---

## Complexity Analysis

**Time Complexity:** O(2ⁿ · n) — there are 2ⁿ subsets, each taking O(n) to copy.

**Space Complexity:** O(2ⁿ · n) — the output contains all subsets.

---

## Solutions

### Go

<Code problemNumber={78} difficulty="medium" lang="go" />

---

## Key Insights

- Every node in the recursion tree (not just leaves) represents a valid subset — append at entry, not just at leaves.
- Always copy the current path before appending to results to avoid later mutations affecting stored subsets.
- An iterative bitmask approach is equally valid: for each integer `mask` from `0` to `2ⁿ - 1`, include `nums[i]` if bit `i` of `mask` is set.
